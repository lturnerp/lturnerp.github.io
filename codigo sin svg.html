<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Proyectos Yadran~REVER</title>
  <link rel="shortcut icon" href="data:image/svg+xml;base64,PHN2ZyBpZD0iQ2FwYV8xIiBkYXRhLW5hbWU9IkNhcGEgMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2aWV3Qm94PSIwIDAgNTIxLjYyIDUyMS42MiI+PGRlZnM+PHN0eWxlPi5jbHMtMXtmaWxsOiNhZjlhNmI7fTwvc3R5bGU+PC9kZWZzPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTI2MC44MSw0OTcuNTksMzczLjYsMjRINDg1LjA1TDM0MS4xOCw0OTYuODNIMTgwLjQzTDM2LjU2LDI0SDE0OFoiLz48L3N2Zz4=" />
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Saira+Condensed:wght@300;400;500;600;700&family=Manrope:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            'primary': '#100F2B', 
            'secondary': '#B7BECC', 
            'accent': '#AF9A6B', 
            'text-main': '#100F2B', 
            'text-light': '#6A737D', 
            'border-color': '#AF9A6B', 
            'checkbox-active': '#AF9A6B', 
            'checkbox-border': '#B7BECC',
          },
          fontFamily: {
            'saira': ['"Saira Condensed"', 'sans-serif'],
            'manrope': ['"Manrope"', 'sans-serif'],
          },
        },
      },
    }
  </script>
  <style>
    body {
      font-family: 'Manrope', sans-serif;
      background-color: #B7BECC; 
      -webkit-user-select: none; /* Safari */
      -ms-user-select: none; /* IE 10+ */
      user-select: none; /* Estándar */
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    // Ya no se necesita DEFAULT_MINDMAP aquí, se cargará desde un archivo

    const generateNodeId = () => {
      return Math.random().toString(36).substr(2, 9);
    };

    const DOC_TYPE_COLORS = {
     "MO": "bg-[#3B82F6]",
     "NP": "bg-[#10B981]",
     "PL": "bg-[#F59E0B]",
     "ORT": "bg-[#8B5CF6]",
     "PANO": "bg-[#EC4899]",
     "DEFAULT": "bg-[#B7BECC]"
    };

    const DOC_TYPE_MAP = {
      "MO": "Modelo 3D",
      "NP": "Nube de Puntos",
      "PL": "Planos",
      "ORT": "Ortofotografía",
      "PANO": "Panoramas"
    };

    const Header = () => {
      return (
        <header className="bg-primary text-white p-3 shadow-md sticky top-0 z-50">
          <div className="container mx-auto flex items-center justify-between">
            <div className="logo-left h-8 md:h-10">
              <svg [codigo svg]</svg>
            </div>
            <div className="logo-right h-8 md:h-10">
              <svg [codigo svg]</svg>
            </div>
          </div>
        </header>
      );
    };

    const CheckboxIcon = ({ checked, onChange }) => {
      return (
        <button
          type="button"
          onClick={onChange}
          className="inline-flex items-center justify-center focus:outline-none mr-1 flex-shrink-0"
          aria-label={checked ? "Checked" : "Unchecked"}
        >
          <div
            className={`w-4 h-4 border-2 rounded ${checked ? 'bg-checkbox-active border-checkbox-active' : 'border-checkbox-border'}`}
          >
            {checked && (
              <div className="w-full h-full flex items-center justify-center">
                <div className="w-2 h-2 bg-white rounded-sm"></div>
              </div>
            )}
          </div>
        </button>
      );
    };

    const ExpandCollapseIcon = ({ expanded, onClick, hasChildren }) => {
      if (!hasChildren) {
        return <span className="w-5 h-5 mr-1 flex-shrink-0"></span>;
      }
      return (
        <button
          type="button"
          onClick={onClick}
          className="w-5 h-5 mr-1 focus:outline-none text-text-light hover:text-text-main transition-colors flex-shrink-0"
          aria-label={expanded ? 'Collapse' : 'Expand'}
        >
          <svg
            className={`w-4 h-4 transform transition-transform duration-200 ${expanded ? 'rotate-90' : ''}`}
            fill="currentColor"
            viewBox="0 0 20 20"
          >
            <path
              fillRule="evenodd"
              d="M7.293 4.293a1 1 0 011.414 0l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414-1.414L10.586 9 7.293 5.707a1 1 0 010-1.414z"
              clipRule="evenodd"
            />
          </svg>
        </button>
      );
    };

    const ColorIndicator = ({ colorClass }) => {
      const finalColorClass = colorClass || DOC_TYPE_COLORS.DEFAULT;
      return (
        <span className={`inline-block w-3 h-3 ${finalColorClass} rounded-full mr-2 flex-shrink-0`}></span>
      );
    };

    const MindMapNode = ({ node, level, onToggleChecked, onToggleExpanded, inheritedColor }) => {
      const paddingLeft = `${level * 20}px`; 
      const hasChildren = node.children && node.children.length > 0;

      const currentNodeColorClass = node.docTypeCode ? (DOC_TYPE_COLORS[node.docTypeCode] || DOC_TYPE_COLORS.DEFAULT) : inheritedColor;

      const handleCheckboxToggle = (e) => {
        e.stopPropagation();
        onToggleChecked(node.id);
      };

      const handleNodeClick = (e) => {
        if (e.target.tagName === 'A' || e.target.closest('a') || e.target.closest('button[aria-label*="Checked"]')) {
          return;
        }
        if (hasChildren) {
            e.stopPropagation(); 
            onToggleExpanded(node.id);
        }
      };
      
      const handleIconClickToExpand = (e) => {
        e.stopPropagation();
        if (hasChildren) {
            onToggleExpanded(node.id);
        }
      }

      const renderContent = () => {
        let tooltip = node.originalContent; 
        
        if (node.isParsedFolder) {
            tooltip = `Original: ${node.parsedNodeOriginalText}\n`;
            if (node.docTypeFull) tooltip += `Tipo Doc.: ${node.docTypeFull}\n`;
            if (node.projectName) tooltip += `Proyecto: ${node.projectName}\n`;
            tooltip += `Estatus: ${node.status || 'N/A'}, Revisión: ${node.revision || 'N/A'}`;
        } else if (node.linkUrl && node.originalContent !== node.displayContent) {
            tooltip = `Enlace: ${node.displayContent}\nURL: ${node.linkUrl}\nOriginal Markdown: ${node.originalContent}`;
        } else if (node.originalContent !== node.displayContent) { 
            tooltip = `Original Markdown: ${node.originalContent}`;
        }

        const mainTextClasses = `
          truncate font-manrope 
          ${node.checked ? 'font-semibold text-accent' : 'text-text-main'}
        `;
        
        const containerClasses = `
            ml-1 flex-grow min-w-0 
            ${hasChildren ? 'cursor-pointer' : 'cursor-default'} 
        `;

        const textToShowAsMain = node.displayContent; 
        const textToShowAsOriginal = node.isParsedFolder ? node.parsedNodeOriginalText : null;

        return (
          <div 
            className={`flex items-baseline justify-between w-full ${containerClasses}`} 
            title={tooltip}
          >
            <div className="truncate mr-2"> 
              {node.linkUrl ? (
                <a
                  href={node.linkUrl}
                  target="_blank"
                  rel="noopener noreferrer"
                  className={`text-blue-600 hover:text-blue-800 hover:underline ${mainTextClasses} ${node.checked ? 'text-accent' : ''}`}
                  onClick={(e) => e.stopPropagation()} 
                >
                  {textToShowAsMain}
                </a>
              ) : (
                <span className={mainTextClasses}>
                  {textToShowAsMain}
                </span>
              )}
            </div>

            {textToShowAsOriginal && (
              <span
                className="hidden sm:inline-block text-xs text-text-light font-manrope font-normal whitespace-nowrap truncate flex-shrink-0" 
                title={textToShowAsOriginal}
              >
                 {textToShowAsOriginal}
              </span>
            )}
          </div>
        );
      };
      
      let nodeBaseClasses = "flex items-center py-1.5 px-2 hover:bg-secondary rounded transition-colors duration-200 text-text-main";
      if (node.isHeaderLine) {
        nodeBaseClasses += " font-saira";
        if (level === 0) nodeBaseClasses += " font-bold text-xl mt-2 mb-1"; 
        else if (level === 1) nodeBaseClasses += " font-semibold text-lg mt-1";
      } else {
        nodeBaseClasses += " font-manrope";
        if (level === 0) nodeBaseClasses += " font-semibold text-lg"; 
        else if (level === 1) nodeBaseClasses += " font-medium text-base";
        else nodeBaseClasses += " text-sm";
      }

      return (
        <>
          <div
            className={nodeBaseClasses}
            style={{ paddingLeft: level > 0 ? paddingLeft : '0px' }} 
            onClick={handleNodeClick} 
          >
            {level >= 1 ? (
              <ColorIndicator colorClass={currentNodeColorClass} />
            ) : (
              <span className="w-3 h-3 mr-2 flex-shrink-0"></span>
            )}

            <ExpandCollapseIcon
              expanded={node.expanded}
              onClick={handleIconClickToExpand} 
              hasChildren={hasChildren}
            />  

            {node.isCheckbox && (
              <CheckboxIcon
                checked={node.checked || false}
                onChange={handleCheckboxToggle}
              />
            )}
            {renderContent()}
          </div>

          {node.expanded && node.children && (
            <div className="transition-all duration-200 ease-in-out">
              {node.children.map((childNode) => (
                <MindMapNode
                  key={childNode.id}
                  node={childNode}
                  level={level + 1}
                  onToggleChecked={onToggleChecked}
                  onToggleExpanded={onToggleExpanded}
                  inheritedColor={currentNodeColorClass} 
                />
              ))}
            </div>
          )}
        </>
      );
    };

        const MindMap = ({ data, onNodesChange }) => {
      const [rootNode, setRootNode] = React.useState(data);

      React.useEffect(() => {
        setRootNode(data);
      }, [data]);

      const updateNodeRecursively = (currentNode, nodeId, updateFn) => {
        // ... (sin cambios en esta función)
        if (currentNode.id === nodeId) {
          return updateFn(currentNode);
        }
        if (currentNode.children && currentNode.children.length > 0) {
          const newChildren = currentNode.children.map(child => 
            updateNodeRecursively(child, nodeId, updateFn)
          );
          if (newChildren.some((child, index) => child !== currentNode.children[index])) {
            return { ...currentNode, children: newChildren };
          }
        }
        return currentNode;
      };
      
      const handleToggleChecked = (nodeId) => {
        // ... (sin cambios en esta función)
        const newRootNode = updateNodeRecursively(rootNode, nodeId, node => ({
          ...node,
          checked: !node.checked
        }));
        setRootNode(newRootNode);
        onNodesChange(newRootNode);
      };

      const handleToggleExpanded = (nodeId) => {
        // ... (sin cambios en esta función)
        const newRootNode = updateNodeRecursively(rootNode, nodeId, node => ({
          ...node,
          expanded: !node.expanded
        }));
        setRootNode(newRootNode);
        onNodesChange(newRootNode);
      };
      
      if (!rootNode || !rootNode.id) {
          return <div className="p-4 bg-white rounded-lg shadow-lg text-center text-text-main font-manrope">Cargando datos del mapa...</div>;
      }

      // ----- INICIO DE CAMBIOS -----
      return (
        <div className="p-4 bg-white rounded-lg shadow-lg">
          {/* Contenedor del título principal y los botones/enlaces */}
          <div className="flex flex-col sm:flex-row items-start sm:items-center justify-between mb-4 space-y-2 sm:space-y-0"> {/* Ajuste para responsividad */}
            
            {/* Título principal del MindMap */}
            <div 
              className="flex items-center text-2xl font-saira font-bold text-primary cursor-default"
              title={rootNode.originalContent || rootNode.displayContent}
            >
              <span className="ml-1">{rootNode.displayContent}</span>
            </div>

            {/* Contenedor para texto y botones a la derecha */}
            <div className="flex items-center space-x-3"> {/* Aumentar space-x si es necesario */}
              <span className="text-sm font-manrope text-text-main"> {/* Texto descriptivo */}
                Ver Proyectos en:
              </span>
              
              {/* Botón Dalux */}
              <a 
                href="https://build.dalux.com/client/310501216368984064/box/files/317742737728208896" 
                target="_blank" 
                rel="noopener noreferrer"
                title="Ver proyectos en Dalux"
                className="
                  flex items-center justify-center 
                  bg-secondary hover:bg-opacity-80 text-primary 
                  p-2 rounded shadow 
                  transition-colors duration-150
                " // Clases de Tailwind para estilo de botón
              >
                <svg[codigo svg]</svg>
                <span className="ml-2 hidden sm:inline"></span> {/* Texto opcional junto al icono */}
              </a>

              {/* Botón Prevu3D */}
              <a 
                href="https://rever.prevu3d.com/nodes/d94f902c-8e91-4561-bbb5-b3604cbf9e57" 
                target="_blank" 
                rel="noopener noreferrer"
                title="Ver proyectos en Prevu3D"
                className="
                  flex items-center justify-center 
                  bg-secondary hover:bg-opacity-80 text-primary 
                  p-2 rounded shadow 
                  transition-colors duration-150
                " // Clases de Tailwind para estilo de botón
              >
                <svg[codigo svg]</svg>
                <span className="ml-2 hidden sm:inline"></span> {/* Texto opcional junto al icono */}
              </a>
            </div>
          </div>
          {/* ----- FIN DE CAMBIOS ----- */}

          {rootNode.expanded && rootNode.children && rootNode.children.length > 0 && (
            <div className="border-l-2 border-border-color"> 
              {rootNode.children.map(node => (
                <MindMapNode
                  key={node.id}
                  node={node}
                  level={0} 
                  onToggleChecked={handleToggleChecked}
                  onToggleExpanded={handleToggleExpanded}
                  inheritedColor={node.docTypeCode ? (DOC_TYPE_COLORS[node.docTypeCode] || DOC_TYPE_COLORS.DEFAULT) : DOC_TYPE_COLORS.DEFAULT}
                />
              ))}
            </div>
          )}
        </div>
      );
    };

    function parseNodeNameAndDetails(textToParse) {
      let docTypeCode = null;
      let docTypeFull = null;
      let status = null;
      let revision = null;
      let projectName = "";
      let isParsedFolder = false;

      const subfolderRegex = /^([A-Z0-9]+)-([A-Z]{2,4})-([0-9]+)-(.+)-([TC])-(A|B|0)$/i;
      const mainFolderRegex = /^([A-Z0-9]+)-(.+)-([TC])-(A|B|0)$/i;

      let match = textToParse.match(subfolderRegex);
      if (match) {
        isParsedFolder = true;
        docTypeCode = match[2].toUpperCase();
        projectName = match[4].trim();
        status = match[5].toUpperCase();
        revision = match[6].toUpperCase();
        docTypeFull = DOC_TYPE_MAP[docTypeCode] || docTypeCode; 
      } else {
        match = textToParse.match(mainFolderRegex);
        if (match) {
          isParsedFolder = true;
          projectName = match[2].trim();
          status = match[3].toUpperCase();
          revision = match[4].toUpperCase();
        }
      }
      return { docTypeCode, docTypeFull, status, revision, projectName, isParsedFolder, parsedNodeOriginalText: textToParse };
    }

    function parseMarkdownToMindMap(markdown) {
      const lines = markdown.split('\n').filter(line => line.trim());
      if (lines.length === 0) {
        return { 
            id: generateNodeId(), 
            originalContent: "Mindmap Vacío", 
            displayContent: "Mindmap Vacío", 
            parsedNodeOriginalText: "Mindmap Vacío",
            children: [], 
            expanded: true, 
            isHeaderLine: true 
        };
      }

      const pseudoRoot = { id: 'pseudo-root', children: [], level: -1, isHeaderContext: false, isParsedFolder: false, docTypeCode: null, originalContent: "PSEUDO_ROOT" };
      const stack = [pseudoRoot];
      const linkRegex = /\[([^\]]+)\]\(([^)]+)\)/; // Regex para [texto](url)

      let isFirstNode = true; 

      lines.forEach(line => {
        const trimmedLine = line.trim();
        const indentLevel = line.search(/\S|$/);
        
        let textAfterPrefixes = trimmedLine.replace(/^[#\-\s]*/, '');
        const isCheckbox = textAfterPrefixes.startsWith('[ ]');
        if (isCheckbox) {
          textAfterPrefixes = textAfterPrefixes.substring(3).trim();
        }
        
        const originalContentForNode = textAfterPrefixes; 
        let textForDetailsParsing = originalContentForNode;
        let linkUrl = null;
        let linkTextIfAny = null;
        let extraDescriptionText = ''; // NUEVO: para almacenar la descripción extra

        const linkMatch = originalContentForNode.match(linkRegex);
        if (linkMatch) {
          linkTextIfAny = linkMatch[1];
          linkUrl = linkMatch[2];
          textForDetailsParsing = linkTextIfAny; // El nombre a parsear está DENTRO del [texto del enlace]
          
          // NUEVO: Capturar texto DESPUÉS del enlace Markdown
          const textAfterLinkSyntax = originalContentForNode.substring(linkMatch[0].length).trim();
          if (textAfterLinkSyntax.startsWith('-')) {
            extraDescriptionText = textAfterLinkSyntax.substring(1).trim(); // Quita el '-' inicial y espacios
          } else {
            extraDescriptionText = textAfterLinkSyntax; // Si no empieza con '-', tomarlo tal cual (o decidir ignorarlo)
          }
        }
        // Si no es un enlace, textForDetailsParsing sigue siendo originalContentForNode

        const details = parseNodeNameAndDetails(textForDetailsParsing);
        let finalDisplayContent;
        
        const isHeaderLine = trimmedLine.startsWith('#');
        let nodeLevel;
        if (isHeaderLine) {
            nodeLevel = (trimmedLine.match(/^#+/) || [''])[0].length - 2; 
        } else {
            nodeLevel = Math.floor(indentLevel / 2); 
        }

        while (stack.length > 1 && stack[stack.length - 1].level >= nodeLevel &&
               !(isHeaderLine && stack[stack.length-1].level === nodeLevel -1 && stack[stack.length-1].isHeaderContext && nodeLevel > stack[stack.length-1].level) &&
               !(!isHeaderLine && stack[stack.length-1].isHeaderContext && nodeLevel > stack[stack.length-1].level)
        ) {
            if (isHeaderLine) {
                if (stack[stack.length-1].level >= nodeLevel) stack.pop(); else break;
            } else { 
                if (stack[stack.length - 1].level >= nodeLevel && !stack[stack.length - 1].isHeaderContext) stack.pop();
                else if (stack[stack.length - 1].isHeaderContext && nodeLevel <= stack[stack.length - 1].level) stack.pop(); 
                else break;
            }
        }
        
        const parentNodeFromStack = stack[stack.length - 1];

        // MODIFICADO: Lógica para construir finalDisplayContent
        if (details.isParsedFolder) {
            if (details.docTypeCode && DOC_TYPE_MAP[details.docTypeCode]) { // Si es una carpeta parseada CON tipo de documento
                finalDisplayContent = DOC_TYPE_MAP[details.docTypeCode]; // Ej: "Nube de Puntos"
                if (extraDescriptionText) {
                    finalDisplayContent += ` ${extraDescriptionText}`; // Ej: "Nube de Puntos 2023"
                }
            } else { // Carpeta parseada sin tipo de documento específico (ej: carpeta de proyecto principal)
                finalDisplayContent = details.projectName;
                if (extraDescriptionText && !linkUrl) { // Añadir solo si no es un enlace, para no duplicar con el siguiente bloque
                    finalDisplayContent += ` ${extraDescriptionText}`;
                }
            }
        } else if (linkUrl) { // Es un enlace pero no una "carpeta parseada con tipo"
            finalDisplayContent = linkTextIfAny || details.parsedNodeOriginalText; // Texto del enlace
            if (extraDescriptionText) {
                finalDisplayContent += ` ${extraDescriptionText}`; // Añade la descripción
            }
        } else { // Texto plano, no es carpeta parseada con tipo, no es enlace
            finalDisplayContent = details.parsedNodeOriginalText;
            if (extraDescriptionText) {
                 finalDisplayContent += ` ${extraDescriptionText}`;
            }
        }
        
        const shouldBeExpanded = isFirstNode; 
        if (isFirstNode) isFirstNode = false;

        const newNode = {
            id: generateNodeId(),
            originalContent: originalContentForNode, 
            displayContent: finalDisplayContent,      
            ...details, 
            linkUrl,
            // Podrías guardar extraDescriptionText aquí también si lo necesitas por separado
            // extraDescriptionText: extraDescriptionText, 
            children: [],
            expanded: shouldBeExpanded, 
            isCheckbox,
            isHeaderLine,
            // Aseguramos que parsedNodeOriginalText en el nodo sea el texto antes de la descripción extra para el tooltip de carpeta
            parsedNodeOriginalText: details.isParsedFolder ? details.parsedNodeOriginalText : originalContentForNode, 
        };

        stack[stack.length - 1].children.push(newNode);
        stack.push({ 
            ...newNode, 
            level: nodeLevel, 
            isHeaderContext: isHeaderLine 
        }); 
      });
      
      const actualRootNode = pseudoRoot.children[0];
      if (actualRootNode) {
        return actualRootNode;
      }
      
      return { 
        id: generateNodeId(), 
        originalContent: "Error: No se pudieron parsear los datos", 
        displayContent: "Error de Parseo", 
        parsedNodeOriginalText: "Error de Parseo",
        children: [], 
        expanded: true, 
        isHeaderLine: true 
      };
    }

    const Legend = () => {
    const documentTypes = Object.entries(DOC_TYPE_MAP).map(([code, name]) => ({
        code,
        name,
        colorClass: DOC_TYPE_COLORS[code] || DOC_TYPE_COLORS.DEFAULT
    }));

    const statusTypes = [
        { code: "C", description: "Compartido" },
        { code: "T", description: "Trabajo en progreso" }
    ];

    const revisionTypes = [
        { code: "A", description: "Revisión Alfabética (A, B, C...)" },
        { code: "0", description: "Revisión Numérica (0, 1, 2...)" }
    ];

    const folderPatterns = [
        {
            description: "CARPETA PRINCIPAL DEL PROYECTO",
            code: "PR#-NOMBREPROYECTO-ESTADO-REV"
        },
        {
            description: "SUBCARPETA DE TIPO DE DOCUMENTO",
            code: "PR#-TIPO-#-NOMBRE-ESTADO-REV"
        }
    ];

    return (
        <div className="p-4 bg-white rounded-lg shadow-lg">
            <h3 className="text-xl font-saira font-bold mb-1 text-primary text-center">
                Codificación de Carpetas
            </h3>
            <p className="text-sm font-manrope text-text-main mb-4 text-center md:text-left"> 
                Los nombres de las carpetas siguen un patrón para identificar proyectos y tipos de documentos:
            </p>
            <div className="mb-6">
                <div className="flex justify-center">
                    <div className="inline-block text-left space-y-2"> 
                        {folderPatterns.map((pattern, index) => (
                            <div key={index}>
                                <p className="text-sm font-manrope text-text-main font-semibold mb-2 text-center">{pattern.description}</p>
                                <code className="block bg-secondary px-2 py-1 rounded text-sm text-text-main mt-0.5">
                                    {pattern.code}
                                </code>
                            </div>
                        ))}
                    </div>
                </div>
            </div>
            <div className="space-y-5">
                <div>
                    <p className="text-sm font-manrope text-text-main font-semibold mb-2 text-center">
                        TIPO
                    </p>
                    <div className="flex justify-center">
                        <ul className="space-y-1.5 inline-block text-left">
                            {documentTypes.map(docType => (
                                <li key={docType.code} className="flex items-center text-sm font-manrope">
                                    <span className={`inline-block w-3 h-3 ${docType.colorClass} rounded-full mr-2 flex-shrink-0`}></span>
                                    <span className="text-text-main">
                                        <strong className="font-medium">{docType.code}:</strong> {docType.name}
                                    </span>
                                </li>
                            ))}
                        </ul>
                    </div>
                </div>
                <div>
                    <p className="text-sm font-manrope text-text-main font-semibold mb-2 text-center">
                        ESTADO
                    </p>
                    <div className="flex justify-center">
                        <ul className="space-y-1 inline-block text-left">
                            {statusTypes.map(status => (
                                <li key={status.code} className="text-sm font-manrope">
                                    <span className="text-text-main pl-[calc(0.75rem+0.5rem)]">
                                        <strong className="font-medium">{status.code}:</strong> {status.description}
                                    </span>
                                </li>
                            ))}
                        </ul>
                    </div>
                </div>
                <div>
                    <p className="text-sm font-manrope text-text-main font-semibold mb-2 text-center">
                        REV
                    </p>
                    <div className="flex justify-center">
                        <ul className="space-y-1 inline-block text-left">
                            {revisionTypes.map(rev => (
                                <li key={rev.code} className="text-sm font-manrope">
                                    <span className="text-text-main pl-[calc(0.75rem+0.5rem)]">
                                        <strong className="font-medium">{rev.code}:</strong> {rev.description}
                                    </span>
                                </li>
                            ))}
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    );
};

    function App() {
      const [mindmapData, setMindmapData] = React.useState(null);
      const [loadingError, setLoadingError] = React.useState(null);

      React.useEffect(() => {
        const loadMindmapFromFile = async () => {
          try {
            // Asegúrate de que 'data.md' esté en la misma carpeta que tu HTML,
            // o proporciona la ruta correcta si está en otro lugar accesible por el servidor.
            const response = await fetch('./data.md'); 
            if (!response.ok) {
              throw new Error(`Error al cargar el archivo: ${response.statusText} (status: ${response.status})`);
            }
            const markdownText = await response.text();
            const initialParsedData = parseMarkdownToMindMap(markdownText);
            
            if (initialParsedData && initialParsedData.id) {
                setMindmapData(initialParsedData);
                setLoadingError(null);
            } else {
                // Esto podría ocurrir si parseMarkdownToMindMap devuelve algo inesperado
                // aunque ya tiene un fallback para "Error de Parseo".
                console.error("Fallo al parsear los datos del archivo, incluso después del fallback de parseo.");
                setMindmapData(parseMarkdownToMindMap("")); // Mostrar un mapa vacío como último recurso
                setLoadingError("Error al procesar los datos");
            }
          } catch (error) {
            console.error("Error cargando data.md:", error);
            setLoadingError(`No se pudo cargar la información: ${error.message}.`);
            // Si falla la carga, parsear una cadena vacía para mostrar un mapa vacío
            setMindmapData(parseMarkdownToMindMap("")); 
          }
        };

        loadMindmapFromFile();
      }, []); // El array vacío asegura que esto se ejecute solo una vez, al montar el componente


      const handleNodesChange = (newRootNodeData) => {
        setMindmapData(newRootNodeData);
        // Ya no se guarda en localStorage
      };

      return (
        <div className="min-h-screen flex flex-col"> 
          <Header />
          <main className="flex-grow p-2 sm:p-4">
            <div className="max-w-7xl mx-auto flex flex-col lg:flex-row gap-4">
              
              <div className="flex-grow lg:w-2/3 space-y-4"> 
                {loadingError && (
                  <div className="p-4 bg-red-100 border border-red-400 text-red-700 rounded-lg shadow-lg text-center font-manrope">
                    {loadingError}
                  </div>
                )}
                {mindmapData ? (
                  <MindMap
                    data={mindmapData}
                    onNodesChange={handleNodesChange}
                  />
                ) : (
                  !loadingError && <div className="p-4 bg-white rounded-lg shadow-lg text-center text-text-main font-manrope">Cargando lista...</div>
                )}
              </div>

              <div className="lg:w-1/3 lg:max-w-md flex-shrink-0">
                <Legend />
              </div>

            </div>
          </main>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(
      <React.StrictMode>
        <App />
      </React.StrictMode>
    );
  </script>
</body>
</html>